"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BN = void 0;
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("../utils");
const validations_1 = require("../validations");
/**
 * Class to work with bits in bignumber
 * Immutable, all methods return new value
 */
class BN {
    constructor(value) {
        this.value = value;
    }
    static fromNumber(n) {
        return new BN(BigInt(n));
    }
    static fromHex(hex) {
        (0, assert_1.default)((0, validations_1.isHexString)(hex), 'Invalid hex');
        return new BN(BigInt(hex));
    }
    /**
     * Add value
     */
    add(other) {
        return new BN(this.value + other.value);
    }
    /**
     * Subtract value
     */
    sub(other) {
        return new BN(this.value - other.value);
    }
    setBit(n, value) {
        if (value) {
            return new BN(this.value | (1n << n));
        }
        return new BN(this.value & ~(1n << n));
    }
    getBit(n) {
        return (this.value & (1n << n)) === 0n ? 0 : 1;
    }
    shiftLeft(n) {
        return new BN(this.value << n);
    }
    shiftRight(n) {
        return new BN(this.value >> n);
    }
    and(other) {
        const raw = typeof other === 'bigint' ? other : other.value;
        return new BN(raw & this.value);
    }
    or(other) {
        const raw = typeof other === 'bigint' ? other : other.value;
        return new BN(raw | this.value);
    }
    xor(other) {
        const raw = typeof other === 'bigint' ? other : other.value;
        return new BN(raw ^ this.value);
    }
    isZero() {
        return this.value === 0n;
    }
    isOne() {
        return this.value === 1n;
    }
    /**
     * Return bits defined in `mask` as BN
     *
     * @example
     * const mask = new BitMask(4, 8) // bits 4,5,6,7
     * const bn = new BN(0x1234abcd)
     *
     * new BN(0x2).value === bn.getMask(mask)
     */
    getMask(mask) {
        return this.shiftRight(mask.offset).and(mask.mask);
    }
    /**
     * Set bits defined in `mask` to `value`
     * if value is bigger than mask then error will be thrown
     */
    setMask(mask, value) {
        const raw = typeof value === 'bigint' ? value : value.value;
        (0, assert_1.default)(raw <= mask.mask, `Value 0x${raw.toString(16)} to big for mask ${mask}`);
        return new BN(this.clearMask(mask).value | (raw << mask.offset));
    }
    /**
     * Set bits defined in `mask` to 0s
     */
    clearMask(mask) {
        return new BN(this.value - (mask.toBigInt() & this.value));
    }
    /**
     * Return 0x prefixed string with hex representation of BN, padded with '0s' if `padNum` specified
     */
    toHex(padNum = 0) {
        return (0, utils_1.add0x)(this.value.toString(16).padStart(padNum, '0'));
    }
    /**
     * Convert BN to Number
     *
     * Caution: value will be rounded for numbers > `Number.MAX_SAFE_INTEGER`
     */
    toNumber() {
        return Number(this.value);
    }
}
exports.BN = BN;
//# sourceMappingURL=bn.js.map