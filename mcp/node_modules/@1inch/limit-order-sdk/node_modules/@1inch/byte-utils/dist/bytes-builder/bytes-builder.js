"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BytesBuilder = void 0;
const assert_1 = __importDefault(require("assert"));
const bn_1 = require("../bn/bn");
const validations_1 = require("../validations");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
/**
 * Helper class to build an arbitrary bytes sequence
 */
class BytesBuilder {
    constructor(init) {
        if (init === undefined) {
            this.bytes = '0x';
            return;
        }
        if (typeof init === 'string') {
            (0, assert_1.default)((0, validations_1.isHexBytes)(init), 'Init bytes must be valid hex bytes');
            this.bytes = init;
        }
        else {
            const initBn = init instanceof bn_1.BN ? init : new bn_1.BN(init);
            this.bytes = initBn.toHex();
        }
    }
    /**
     * Returns current bytes count
     */
    get length() {
        return Number(this.bytes.length / 2 - 1);
    }
    addAddress(address) {
        if (typeof address === 'string') {
            (0, assert_1.default)((0, validations_1.isHexBytes)(address) && address.length === 42, 'Invalid address');
            this.append(address);
        }
        else {
            const addressBN = address instanceof bn_1.BN ? address : new bn_1.BN(address);
            (0, assert_1.default)(addressBN.value <= constants_1.UINT_160_MAX, 'Invalid address: too big');
            this.append(addressBN.toHex(40));
        }
        return this;
    }
    addBytes(bytes) {
        (0, assert_1.default)((0, validations_1.isHexBytes)(bytes), 'Invalid bytes');
        this.append(bytes);
        return this;
    }
    addByte(byte) {
        return this.addNBytes(byte, 1);
    }
    addUint8(val) {
        return this.addNBytes(val, 1);
    }
    addUint16(val) {
        return this.addNBytes(val, 2);
    }
    addUint24(val) {
        return this.addNBytes(val, 3);
    }
    addUint32(val) {
        return this.addNBytes(val, 4);
    }
    addUint64(val) {
        return this.addNBytes(val, 8);
    }
    addUint128(val) {
        return this.addNBytes(val, 16);
    }
    addUint160(val) {
        return this.addNBytes(val, 20);
    }
    addUint256(val) {
        return this.addNBytes(val, 32);
    }
    /**
     * Returns bytes as single bigint value
     */
    asBigInt() {
        return BigInt(this.bytes);
    }
    /**
     * Returns hex string
     *
     * @param prefixed should be string prefixed with 0x or not, true by default
     */
    asHex(prefixed = true) {
        return prefixed ? this.bytes : this.bytes.slice(2);
    }
    append(bytes) {
        this.bytes += (0, utils_1.trim0x)(bytes);
    }
    addNBytes(bytes, n) {
        if (typeof bytes === 'string') {
            (0, assert_1.default)((0, validations_1.isHexBytes)(bytes), 'Invalid value: not bytes hex string');
            (0, assert_1.default)(bytes.length === 2 + n * 2, 'Invalid value: bad length');
            this.append(bytes);
        }
        else {
            const bytesBn = bytes instanceof bn_1.BN ? bytes : new bn_1.BN(bytes);
            (0, assert_1.default)(bytesBn.value <= (1n << (8n * BigInt(n))) - 1n, 'Invalid value: too long');
            this.append(bytesBn.toHex(n * 2));
        }
        return this;
    }
}
exports.BytesBuilder = BytesBuilder;
//# sourceMappingURL=bytes-builder.js.map