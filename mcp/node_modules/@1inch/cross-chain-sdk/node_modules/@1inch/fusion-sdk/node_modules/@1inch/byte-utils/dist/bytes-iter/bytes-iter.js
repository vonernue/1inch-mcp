"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BytesIter = void 0;
const assert_1 = __importDefault(require("assert"));
const validations_1 = require("../validations");
const utils_1 = require("../utils");
var Side;
(function (Side) {
    Side[Side["Front"] = 0] = "Front";
    Side[Side["Back"] = 1] = "Back";
})(Side || (Side = {}));
/**
 * Class to iterate through bytes string by parsing individual bytes
 *
 * @example
 * const iter = BytesIter.BigInt('0xdeadbeef')
 * iter.nextByte() == BigInt(0xde)
 * iter.nextByte() == BigInt(0xad)
 * iter.nextBytes(2) == BigInt(0xbeef)
 */
class BytesIter {
    constructor(bytes, ResultType) {
        this.ResultType = ResultType;
        (0, assert_1.default)((0, validations_1.isHexBytes)(bytes), 'invalid bytes value');
        this.bytes = bytes.slice(2); // trim 0x
    }
    static BigInt(bytes) {
        return new BytesIter(bytes, BigInt);
    }
    static String(bytes) {
        return new BytesIter(bytes, String);
    }
    /**
     * Returns all not consumed bytes
     */
    rest() {
        return this.ResultType((0, utils_1.add0x)(this.bytes));
    }
    isEmpty() {
        return this.bytes.length === 0;
    }
    nextByte(side = Side.Front) {
        return this.nextBytes(1, side);
    }
    nextBytes(n, side = Side.Front) {
        const cnt = n * 2;
        if (this.bytes.length < cnt) {
            throw new Error(`Can not consume ${n} bytes, have only ${this.bytes.length / 2}`);
        }
        const isFront = side === Side.Front;
        const bytes = isFront
            ? this.bytes.slice(0, cnt)
            : this.bytes.slice(-cnt);
        this.bytes = isFront ? this.bytes.slice(cnt) : this.bytes.slice(0, -cnt);
        return this.ResultType((0, utils_1.add0x)(bytes));
    }
    nextAddress(side = Side.Front) {
        return this.nextBytes(40, side);
    }
    nextUint8(side = Side.Front) {
        return this.nextByte(side);
    }
    nextUint16(side = Side.Front) {
        return this.nextBytes(2, side);
    }
    nextUint24(side = Side.Front) {
        return this.nextBytes(3, side);
    }
    nextUint32(side = Side.Front) {
        return this.nextBytes(4, side);
    }
    nextUint128(side = Side.Front) {
        return this.nextBytes(16, side);
    }
    nextUint160(side = Side.Front) {
        return this.nextBytes(20, side);
    }
    nextUint256(side = Side.Front) {
        return this.nextBytes(32, side);
    }
}
exports.BytesIter = BytesIter;
BytesIter.SIDE = Side;
//# sourceMappingURL=bytes-iter.js.map