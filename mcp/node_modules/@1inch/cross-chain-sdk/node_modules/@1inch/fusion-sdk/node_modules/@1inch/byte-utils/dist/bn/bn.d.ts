import { BitMask } from '../bit-mask/bit-mask';
/**
 * Class to work with bits in bignumber
 * Immutable, all methods return new value
 */
export declare class BN {
    readonly value: bigint;
    constructor(value: bigint);
    static fromNumber(n: number): BN;
    static fromHex(hex: string): BN;
    /**
     * Add value
     */
    add(other: BN): BN;
    /**
     * Subtract value
     */
    sub(other: BN): BN;
    setBit(n: bigint, value: 1 | 0): BN;
    getBit(n: bigint): 1 | 0;
    shiftLeft(n: bigint): BN;
    shiftRight(n: bigint): BN;
    and(other: BN | bigint): BN;
    or(other: BN | bigint): BN;
    xor(other: BN | bigint): BN;
    isZero(): boolean;
    isOne(): boolean;
    /**
     * Return bits defined in `mask` as BN
     *
     * @example
     * const mask = new BitMask(4, 8) // bits 4,5,6,7
     * const bn = new BN(0x1234abcd)
     *
     * new BN(0x2).value === bn.getMask(mask)
     */
    getMask(mask: BitMask): BN;
    /**
     * Set bits defined in `mask` to `value`
     * if value is bigger than mask then error will be thrown
     */
    setMask(mask: BitMask, value: BN | bigint): BN;
    /**
     * Set bits defined in `mask` to 0s
     */
    clearMask(mask: BitMask): BN;
    /**
     * Return 0x prefixed string with hex representation of BN, padded with '0s' if `padNum` specified
     */
    toHex(padNum?: number): string;
    /**
     * Convert BN to Number
     *
     * Caution: value will be rounded for numbers > `Number.MAX_SAFE_INTEGER`
     */
    toNumber(): number;
}
