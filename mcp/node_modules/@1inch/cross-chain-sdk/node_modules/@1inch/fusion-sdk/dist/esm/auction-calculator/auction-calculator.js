import { RATE_BUMP_DENOMINATOR } from './constants';
import { addRatioToAmount } from '../sdk';
export class AuctionCalculator {
    constructor(startTime, duration, initialRateBump, points, takerFeeRatio, gasCost = {
        gasBumpEstimate: 0n,
        gasPriceEstimate: 0n
    }) {
        this.startTime = startTime;
        this.duration = duration;
        this.initialRateBump = initialRateBump;
        this.points = points;
        this.takerFeeRatio = takerFeeRatio;
        this.gasCost = gasCost;
    }
    get finishTime() {
        return this.startTime + this.duration;
    }
    static fromAuctionData(data, details) {
        return new AuctionCalculator(details.startTime, details.duration, details.initialRateBump, details.points, data.integratorFee?.ratio || 0n, details.gasCost);
    }
    static calcInitialRateBump(startAmount, endAmount) {
        const bump = (RATE_BUMP_DENOMINATOR * startAmount) / endAmount -
            RATE_BUMP_DENOMINATOR;
        return Number(bump);
    }
    static calcAuctionTakingAmount(takingAmount, rate, takerFeeRatio) {
        const auctionTakingAmount = (BigInt(takingAmount) * (BigInt(rate) + RATE_BUMP_DENOMINATOR)) /
            RATE_BUMP_DENOMINATOR;
        if (takerFeeRatio === 0n) {
            return auctionTakingAmount;
        }
        return addRatioToAmount(auctionTakingAmount, takerFeeRatio);
    }
    static baseFeeToGasPriceEstimate(baseFee) {
        return baseFee / AuctionCalculator.GAS_PRICE_BASE;
    }
    static calcGasBumpEstimate(endTakingAmount, gasCostInToToken) {
        return (gasCostInToToken * RATE_BUMP_DENOMINATOR) / endTakingAmount;
    }
    calcAuctionTakingAmount(takingAmount, rate) {
        return AuctionCalculator.calcAuctionTakingAmount(takingAmount, rate, this.takerFeeRatio);
    }
    calcRateBump(time, blockBaseFee = 0n) {
        const gasBump = this.getGasPriceBump(blockBaseFee);
        const auctionBump = this.getAuctionBump(time);
        const final = auctionBump > gasBump ? auctionBump - gasBump : 0n;
        return Number(final);
    }
    getGasPriceBump(blockBaseFee) {
        if (this.gasCost.gasBumpEstimate === 0n ||
            this.gasCost.gasPriceEstimate === 0n ||
            blockBaseFee === 0n) {
            return 0n;
        }
        return ((this.gasCost.gasBumpEstimate * blockBaseFee) /
            this.gasCost.gasPriceEstimate /
            AuctionCalculator.GAS_PRICE_BASE);
    }
    getAuctionBump(blockTime) {
        const auctionFinishTime = this.finishTime;
        if (blockTime <= this.startTime) {
            return this.initialRateBump;
        }
        else if (blockTime >= auctionFinishTime) {
            return 0n;
        }
        let currentPointTime = this.startTime;
        let currentRateBump = this.initialRateBump;
        for (const { coefficient: nextRateBump, delay } of this.points) {
            const nextPointTime = BigInt(delay) + currentPointTime;
            if (blockTime <= nextPointTime) {
                return (((blockTime - currentPointTime) * BigInt(nextRateBump) +
                    (nextPointTime - blockTime) * currentRateBump) /
                    (nextPointTime - currentPointTime));
            }
            currentPointTime = nextPointTime;
            currentRateBump = BigInt(nextRateBump);
        }
        return (((auctionFinishTime - blockTime) * currentRateBump) /
            (auctionFinishTime - currentPointTime));
    }
}
AuctionCalculator.GAS_PRICE_BASE = 1000000n;
//# sourceMappingURL=auction-calculator.js.map