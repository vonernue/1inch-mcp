import { Address, Extension, ExtensionBuilder, Interaction } from '@1inch/limit-order-sdk';
import assert from 'assert';
import { AuctionDetails } from './auction-details';
import { SettlementPostInteractionData } from './settlement-post-interaction-data';
export class FusionExtension {
    constructor(address, auctionDetails, postInteractionData, makerPermit) {
        this.address = address;
        this.auctionDetails = auctionDetails;
        this.postInteractionData = postInteractionData;
        this.makerPermit = makerPermit;
        this.builder = new ExtensionBuilder();
        const detailsBytes = this.auctionDetails.encode();
        this.builder
            .withMakingAmountData(this.address, detailsBytes)
            .withTakingAmountData(this.address, detailsBytes)
            .withPostInteraction(new Interaction(this.address, this.postInteractionData.encode()));
        if (makerPermit) {
            this.builder.withMakerPermit(makerPermit.target, makerPermit.data);
        }
    }
    static decode(bytes) {
        const extension = Extension.decode(bytes);
        return FusionExtension.fromExtension(extension);
    }
    static fromExtension(extension) {
        const settlementContract = Address.fromFirstBytes(extension.makingAmountData);
        assert(Address.fromFirstBytes(extension.takingAmountData).equal(settlementContract) &&
            Address.fromFirstBytes(extension.postInteraction).equal(settlementContract), 'Invalid extension, all calls should be to the same address');
        const auctionDetails = AuctionDetails.fromExtension(extension);
        const postInteractionData = SettlementPostInteractionData.fromExtension(extension);
        const permit = extension.hasMakerPermit
            ? Interaction.decode(extension.makerPermit)
            : undefined;
        return new FusionExtension(settlementContract, auctionDetails, postInteractionData, permit);
    }
    build() {
        return this.builder.build();
    }
}
//# sourceMappingURL=fusion-extension.js.map