import { Address, Interaction, LimitOrder, MakerTraits } from '@1inch/limit-order-sdk';
import assert from 'assert';
import { FusionExtension } from './fusion-extension';
import { AuctionDetails } from './auction-details';
import { SettlementPostInteractionData } from './settlement-post-interaction-data';
import { injectTrackCode } from './source-track';
import { AuctionCalculator } from '../auction-calculator';
import { ZX } from '../constants';
import { calcTakingAmount } from '../utils/amounts';
import { now } from '../utils/time';
export class FusionOrder {
    constructor(settlementExtensionContract, orderInfo, auctionDetails, postInteractionData, extra = FusionOrder.defaultExtra, extension = new FusionExtension(settlementExtensionContract, auctionDetails, postInteractionData, extra.permit
        ? new Interaction(orderInfo.makerAsset, extra.permit)
        : undefined)) {
        this.settlementExtensionContract = settlementExtensionContract;
        const allowPartialFills = extra.allowPartialFills ??
            FusionOrder.defaultExtra.allowPartialFills;
        const allowMultipleFills = extra.allowMultipleFills ??
            FusionOrder.defaultExtra.allowMultipleFills;
        const unwrapWETH = extra.unwrapWETH ?? FusionOrder.defaultExtra.unwrapWETH;
        const enablePermit2 = extra.enablePermit2 ?? FusionOrder.defaultExtra.enablePermit2;
        const orderExpirationDelay = extra.orderExpirationDelay ??
            FusionOrder.defaultExtra.orderExpirationDelay;
        const deadline = auctionDetails.startTime +
            auctionDetails.duration +
            orderExpirationDelay;
        const makerTraits = MakerTraits.default()
            .withExpiration(deadline)
            .setPartialFills(allowPartialFills)
            .setMultipleFills(allowMultipleFills)
            .enablePostInteraction();
        if (makerTraits.isBitInvalidatorMode()) {
            assert(extra.nonce !== undefined, 'Nonce required, when partial fill or multiple fill disallowed');
        }
        if (unwrapWETH) {
            makerTraits.enableNativeUnwrap();
        }
        if (enablePermit2) {
            makerTraits.enablePermit2();
        }
        if (extra.nonce !== undefined) {
            makerTraits.withNonce(extra.nonce);
        }
        const receiver = postInteractionData.integratorFee?.ratio
            ? settlementExtensionContract
            : orderInfo.receiver;
        const builtExtension = extension.build();
        const salt = LimitOrder.buildSalt(builtExtension, orderInfo.salt);
        const saltWithInjectedTrackCode = orderInfo.salt
            ? salt
            : injectTrackCode(salt, extra.source);
        this.inner = new LimitOrder({
            ...orderInfo,
            receiver,
            salt: saltWithInjectedTrackCode
        }, makerTraits, builtExtension);
        this.fusionExtension = extension;
    }
    get extension() {
        return this.inner.extension;
    }
    get maker() {
        return this.inner.maker;
    }
    get takerAsset() {
        return this.inner.takerAsset;
    }
    get makerAsset() {
        return this.inner.makerAsset;
    }
    get takingAmount() {
        return this.inner.takingAmount;
    }
    get makingAmount() {
        return this.inner.makingAmount;
    }
    get receiver() {
        return this.inner.receiver;
    }
    get deadline() {
        return this.inner.makerTraits.expiration() || 0n;
    }
    get auctionStartTime() {
        return this.fusionExtension.auctionDetails.startTime;
    }
    get auctionEndTime() {
        const { startTime, duration } = this.fusionExtension.auctionDetails;
        return startTime + duration;
    }
    get isBitInvalidatorMode() {
        return this.inner.makerTraits.isBitInvalidatorMode();
    }
    get partialFillAllowed() {
        return this.inner.makerTraits.isPartialFillAllowed();
    }
    get multipleFillsAllowed() {
        return this.inner.makerTraits.isMultipleFillsAllowed();
    }
    get nonce() {
        return this.inner.makerTraits.nonceOrEpoch();
    }
    get salt() {
        return this.inner.salt;
    }
    static new(settlementExtension, orderInfo, details, extra) {
        return new FusionOrder(settlementExtension, orderInfo, details.auction, SettlementPostInteractionData.new({
            bankFee: details.fees?.bankFee || 0n,
            integratorFee: details.fees?.integratorFee,
            whitelist: details.whitelist,
            resolvingStartTime: details.resolvingStartTime ?? now(),
            customReceiver: orderInfo.receiver
        }), extra);
    }
    static fromDataAndExtension(order, extension) {
        const settlementContract = Address.fromFirstBytes(extension.makingAmountData);
        assert(Address.fromFirstBytes(extension.takingAmountData).equal(settlementContract) &&
            Address.fromFirstBytes(extension.postInteraction).equal(settlementContract), 'Invalid extension, all calls should be to the same address');
        const makerTraits = new MakerTraits(BigInt(order.makerTraits));
        assert(!makerTraits.isPrivate(), 'fusion order can not be private');
        assert(makerTraits.hasPostInteraction(), 'post-interaction must be enabled');
        const auctionDetails = AuctionDetails.fromExtension(extension);
        const postInteractionData = SettlementPostInteractionData.fromExtension(extension);
        const deadline = makerTraits.expiration();
        const orderExpirationDelay = deadline === null
            ? undefined
            : deadline - auctionDetails.startTime - auctionDetails.duration;
        return new FusionOrder(settlementContract, {
            salt: BigInt(order.salt) >> 160n,
            maker: new Address(order.maker),
            receiver: new Address(order.receiver),
            makerAsset: new Address(order.makerAsset),
            takerAsset: new Address(order.takerAsset),
            makingAmount: BigInt(order.makingAmount),
            takingAmount: BigInt(order.takingAmount)
        }, auctionDetails, postInteractionData, {
            allowMultipleFills: makerTraits.isMultipleFillsAllowed(),
            allowPartialFills: makerTraits.isPartialFillAllowed(),
            enablePermit2: makerTraits.isPermit2(),
            nonce: makerTraits.nonceOrEpoch(),
            permit: extension.makerPermit === ZX
                ? undefined
                : Interaction.decode(extension.makerPermit).data,
            unwrapWETH: makerTraits.isNativeUnwrapEnabled(),
            orderExpirationDelay
        });
    }
    build() {
        return this.inner.build();
    }
    getOrderHash(chainId) {
        return this.inner.getOrderHash(chainId);
    }
    getTypedData(chainId) {
        return this.inner.getTypedData(chainId);
    }
    getCalculator() {
        return AuctionCalculator.fromAuctionData(this.fusionExtension.postInteractionData, this.fusionExtension.auctionDetails);
    }
    calcTakingAmount(makingAmount, time, blockBaseFee = 0n) {
        const takingAmount = calcTakingAmount(makingAmount, this.makingAmount, this.takingAmount);
        const calculator = this.getCalculator();
        const bump = calculator.calcRateBump(time, blockBaseFee);
        return calculator.calcAuctionTakingAmount(takingAmount, bump);
    }
    canExecuteAt(executor, executionTime) {
        return this.fusionExtension.postInteractionData.canExecuteAt(executor, executionTime);
    }
    isExpiredAt(time) {
        return time > this.deadline;
    }
    getResolverFee(filledMakingAmount) {
        return ((this.fusionExtension.postInteractionData.bankFee *
            FusionOrder._ORDER_FEE_BASE_POINTS *
            filledMakingAmount) /
            this.makingAmount);
    }
    isExclusiveResolver(wallet) {
        return this.fusionExtension.postInteractionData.isExclusiveResolver(wallet);
    }
    isExclusivityPeriod(time = now()) {
        return this.fusionExtension.postInteractionData.isExclusivityPeriod(time);
    }
}
FusionOrder._ORDER_FEE_BASE_POINTS = 10n ** 15n;
FusionOrder.defaultExtra = {
    allowPartialFills: true,
    allowMultipleFills: true,
    unwrapWETH: false,
    enablePermit2: false,
    orderExpirationDelay: 12n
};
//# sourceMappingURL=fusion-order.js.map