import { BytesLike, HexString } from './bytes';
import { MultiProof } from './core';
import { MerkleTreeData, MerkleTreeImpl } from './merkletree';
import { MerkleTreeOptions } from './options';
export interface StandardMerkleTreeData<T extends any[]> extends MerkleTreeData<T> {
    format: 'standard-v1';
    leafEncoding: string[];
}
export declare class StandardMerkleTree<T extends any[]> extends MerkleTreeImpl<T> {
    protected readonly tree: HexString[];
    protected readonly values: StandardMerkleTreeData<T>['values'];
    protected readonly leafEncoding: string[];
    protected constructor(tree: HexString[], values: StandardMerkleTreeData<T>['values'], leafEncoding: string[]);
    static of<T extends any[]>(values: T[], leafEncoding: string[], options?: MerkleTreeOptions): StandardMerkleTree<T>;
    static load<T extends any[]>(data: StandardMerkleTreeData<T>): StandardMerkleTree<T>;
    static verify<T extends any[]>(root: BytesLike, leafEncoding: string[], leaf: T, proof: BytesLike[]): boolean;
    static verifyMultiProof<T extends any[]>(root: BytesLike, leafEncoding: string[], multiproof: MultiProof<BytesLike, T>): boolean;
    dump(): StandardMerkleTreeData<T>;
}
//# sourceMappingURL=standard.d.ts.map