"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderMerkleTree = exports.isValidMerkleTree = exports.processMultiProof = exports.getMultiProof = exports.processProof = exports.getProof = exports.makeMerkleTree = void 0;
const bytes_1 = require("./bytes");
const hashes_1 = require("./hashes");
const errors_1 = require("./utils/errors");
const leftChildIndex = (i) => 2 * i + 1;
const rightChildIndex = (i) => 2 * i + 2;
const parentIndex = (i) => (i > 0 ? Math.floor((i - 1) / 2) : (0, errors_1.throwError)('Root has no parent'));
const siblingIndex = (i) => (i > 0 ? i - (-1) ** (i % 2) : (0, errors_1.throwError)('Root has no siblings'));
const isTreeNode = (tree, i) => i >= 0 && i < tree.length;
const isInternalNode = (tree, i) => isTreeNode(tree, leftChildIndex(i));
const isLeafNode = (tree, i) => isTreeNode(tree, i) && !isInternalNode(tree, i);
const isValidMerkleNode = (node) => (0, bytes_1.toBytes)(node).length === 32;
const checkLeafNode = (tree, i) => void (isLeafNode(tree, i) || (0, errors_1.throwError)('Index is not a leaf'));
const checkValidMerkleNode = (node) => void (isValidMerkleNode(node) || (0, errors_1.throwError)('Merkle tree nodes must be Uint8Array of length 32'));
function makeMerkleTree(leaves, nodeHash = hashes_1.standardNodeHash) {
    leaves.forEach(checkValidMerkleNode);
    (0, errors_1.validateArgument)(leaves.length !== 0, 'Expected non-zero number of leaves');
    const tree = new Array(2 * leaves.length - 1);
    for (const [i, leaf] of leaves.entries()) {
        tree[tree.length - 1 - i] = (0, bytes_1.toHex)(leaf);
    }
    for (let i = tree.length - 1 - leaves.length; i >= 0; i--) {
        tree[i] = nodeHash(tree[leftChildIndex(i)], tree[rightChildIndex(i)]);
    }
    return tree;
}
exports.makeMerkleTree = makeMerkleTree;
function getProof(tree, index) {
    checkLeafNode(tree, index);
    const proof = [];
    while (index > 0) {
        proof.push((0, bytes_1.toHex)(tree[siblingIndex(index)]));
        index = parentIndex(index);
    }
    return proof;
}
exports.getProof = getProof;
function processProof(leaf, proof, nodeHash = hashes_1.standardNodeHash) {
    checkValidMerkleNode(leaf);
    proof.forEach(checkValidMerkleNode);
    return (0, bytes_1.toHex)(proof.reduce(nodeHash, leaf));
}
exports.processProof = processProof;
function getMultiProof(tree, indices) {
    indices.forEach(i => checkLeafNode(tree, i));
    indices.sort((a, b) => b - a);
    (0, errors_1.validateArgument)(indices.slice(1).every((i, p) => i !== indices[p]), 'Cannot prove duplicated index');
    const stack = Array.from(indices); // copy
    const proof = [];
    const proofFlags = [];
    while (stack.length > 0 && stack[0] > 0) {
        const j = stack.shift(); // take from the beginning
        const s = siblingIndex(j);
        const p = parentIndex(j);
        if (s === stack[0]) {
            proofFlags.push(true);
            stack.shift(); // consume from the stack
        }
        else {
            proofFlags.push(false);
            proof.push((0, bytes_1.toHex)(tree[s]));
        }
        stack.push(p);
    }
    if (indices.length === 0) {
        proof.push((0, bytes_1.toHex)(tree[0]));
    }
    return {
        leaves: indices.map(i => (0, bytes_1.toHex)(tree[i])),
        proof,
        proofFlags,
    };
}
exports.getMultiProof = getMultiProof;
function processMultiProof(multiproof, nodeHash = hashes_1.standardNodeHash) {
    multiproof.leaves.forEach(checkValidMerkleNode);
    multiproof.proof.forEach(checkValidMerkleNode);
    (0, errors_1.validateArgument)(multiproof.proof.length >= multiproof.proofFlags.filter(b => !b).length, 'Invalid multiproof format');
    (0, errors_1.validateArgument)(multiproof.leaves.length + multiproof.proof.length === multiproof.proofFlags.length + 1, 'Provided leaves and multiproof are not compatible');
    const stack = Array.from(multiproof.leaves); // copy
    const proof = Array.from(multiproof.proof); // copy
    for (const flag of multiproof.proofFlags) {
        const a = stack.shift();
        const b = flag ? stack.shift() : proof.shift();
        (0, errors_1.invariant)(a !== undefined && b !== undefined);
        stack.push(nodeHash(a, b));
    }
    (0, errors_1.invariant)(stack.length + proof.length === 1);
    return (0, bytes_1.toHex)(stack.pop() ?? proof.shift());
}
exports.processMultiProof = processMultiProof;
function isValidMerkleTree(tree, nodeHash = hashes_1.standardNodeHash) {
    for (const [i, node] of tree.entries()) {
        if (!isValidMerkleNode(node)) {
            return false;
        }
        const l = leftChildIndex(i);
        const r = rightChildIndex(i);
        if (r >= tree.length) {
            if (l < tree.length) {
                return false;
            }
        }
        else if ((0, bytes_1.compare)(node, nodeHash(tree[l], tree[r]))) {
            return false;
        }
    }
    return tree.length > 0;
}
exports.isValidMerkleTree = isValidMerkleTree;
function renderMerkleTree(tree) {
    (0, errors_1.validateArgument)(tree.length !== 0, 'Expected non-zero number of nodes');
    const stack = [[0, []]];
    const lines = [];
    while (stack.length > 0) {
        const [i, path] = stack.pop();
        lines.push(path
            .slice(0, -1)
            .map(p => ['   ', '│  '][p])
            .join('') +
            path
                .slice(-1)
                .map(p => ['└─ ', '├─ '][p])
                .join('') +
            i +
            ') ' +
            (0, bytes_1.toHex)(tree[i]));
        if (rightChildIndex(i) < tree.length) {
            stack.push([rightChildIndex(i), path.concat(0)]);
            stack.push([leftChildIndex(i), path.concat(1)]);
        }
    }
    return lines.join('\n');
}
exports.renderMerkleTree = renderMerkleTree;
//# sourceMappingURL=core.js.map